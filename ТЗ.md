**Вариант: 43432**

Разделить программу из [лабораторной работы №5](https://se.ifmo.ru/courses/programming#lab5) на клиентский и серверный модули. Серверный модуль должен осуществлять выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.

**Необходимо выполнить следующие требования:**

- Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
- Объекты между клиентом и сервером должны передаваться в сериализованном виде.
- Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по местоположению
- Клиент должен корректно обрабатывать временную недоступность сервера.
- Обмен данными между клиентом и сервером должен осуществляться по протоколу UDP
- Для обмена данными на сервере необходимо использовать **сетевой канал**
- Для обмена данными на клиенте необходимо использовать **датаграммы**
- Сетевые каналы должны использоваться в неблокирующем режиме.

**Обязанности серверного приложения:**

- Работа с файлом, хранящим коллекцию.
- Управление коллекцией объектов.
- Назначение автоматически генерируемых полей объектов в коллекции.
- Ожидание подключений и запросов от клиента.
- Обработка полученных запросов (команд).
- Сохранение коллекции в файл при завершении работы приложения.
- Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).

**Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):**

- Модуль приёма подключений.
- Модуль чтения запроса.
- Модуль обработки полученных команд.
- Модуль отправки ответов клиенту.

Сервер должен работать в **однопоточном** режиме.

**Обязанности клиентского приложения:**

- Чтение команд из консоли.
- Валидация вводимых данных.
- Сериализация введённой команды и её аргументов.
- Отправка полученной команды и её аргументов на сервер.
- Обработка ответа от сервера (вывод результата исполнения команды в консоль).
- Команду `save` из клиентского приложения необходимо убрать.
- Команда `exit` завершает работу клиентского приложения.

**Важно!** Команды и их аргументы должны представлять из себя объекты классов. Недопустим обмен "простыми" строками. Так, для команды add или её аналога необходимо сформировать объект, содержащий тип команды и объект, который должен храниться в вашей коллекции.

**Дополнительное задание:**  
Реализовать логирование различных этапов работы сервера (начало работы, получение нового подключения, получение нового запроса, отправка ответа и т.п.) с помощью **Log4J2**

**Отчёт по работе должен содержать:**

1. Текст задания.
2. Диаграмма классов разработанной программы (как клиентского, так и серверного приложения).
3. Исходный код программы.
4. Выводы по работе.

**Вопросы к защите лабораторной работы:**

1. Сетевое взаимодействие - клиент-серверная архитектура, основные протоколы, их сходства и отличия.
2. Протокол TCP. Классы `Socket` и `ServerSocket`.
3. Протокол UDP. Классы `DatagramSocket` и `DatagramPacket`.
4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами.
5. Классы `SocketChannel` и `DatagramChannel`.
6. Передача данных по сети. Сериализация объектов.
7. Интерфейс `Serializable`. Объектный граф, сериализация и десериализация полей и методов.
8. Java Stream API. Создание конвейеров. Промежуточные и терминальные операции.
9. Шаблоны проектирования: Decorator, Iterator, Factory method, Command, Flyweight, Interpreter, Singleton, Strategy, Adapter, Facade, Proxy.


# Теория
### 1. Сетевое взаимодействие - клиент-серверная архитектура, основные протоколы, их сходства и отличия.
### 2. Протокол TCP. Классы `Socket` и `ServerSocket`.
#### **Протокол TCP (Transmission Control Protocol)**  

**TCP** — это надежный, потоковый, ориентированный на соединение протокол транспортного уровня модели **OSI** (или **TCP/IP**). Он обеспечивает:  
- **Гарантированную доставку** данных (использует подтверждения и повторные передачи).  
- **Порядок доставки** (пакеты приходят в том же порядке, в котором были отправлены).  
- **Контроль перегрузки** (динамически регулирует скорость передачи).  
- **Полнодуплексную связь** (одновременная передача в обе стороны).  

#### **Основные особенности TCP:**  
1. **Установление соединения (Three-way handshake)**  
   - Клиент отправляет `SYN` (синхронизация).  
   - Сервер отвечает `SYN-ACK` (подтверждение + синхронизация).  
   - Клиент отправляет `ACK` (подтверждение).  
   После этого соединение считается установленным.  

2. **Надежность**  
   - Каждый пакет нумеруется (Sequence Number).  
   - Получатель отправляет подтверждение (`ACK`).  
   - Если `ACK` не приходит, отправитель повторяет передачу.  

3. **Разрыв соединения (Four-way handshake)**  
   - Одна сторона отправляет `FIN`.  
   - Вторая сторона подтверждает (`ACK`) и может отправить свой `FIN`.  
   - Первая сторона подтверждает (`ACK`).  

---

#### **Классы `Socket` и `ServerSocket` в Java**  

В Java для работы с TCP используются два основных класса:  
- **`ServerSocket`** — ожидает подключения клиентов (серверная часть).  
- **`Socket`** — обеспечивает соединение между клиентом и сервером.  

#### **1. `ServerSocket` (серверная сторона)**  
```java
import java.io.*;
import java.net.*;

public class TCPServer {
    public static void main(String[] args) throws IOException {
        // Создание серверного сокета на порту 12345
        ServerSocket serverSocket = new ServerSocket(12345);
        System.out.println("Сервер запущен, ожидание подключения...");

        // Ожидание подключения клиента
        Socket clientSocket = serverSocket.accept();
        System.out.println("Клиент подключен: " + clientSocket.getInetAddress());

        // Получение входного и выходного потоков
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);

        // Чтение данных от клиента
        String message = in.readLine();
        System.out.println("Клиент сказал: " + message);

        // Отправка ответа клиенту
        out.println("Привет, клиент!");

        // Закрытие соединения
        clientSocket.close();
        serverSocket.close();
    }
}
```

#### **2. `Socket` (клиентская сторона)**  
```java
import java.io.*;
import java.net.*;

public class TCPClient {
    public static void main(String[] args) throws IOException {
        // Подключение к серверу (localhost, порт 12345)
        Socket socket = new Socket("localhost", 12345);
        System.out.println("Подключено к серверу");

        // Получение входного и выходного потоков
        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

        // Отправка сообщения серверу
        out.println("Привет, сервер!");

        // Получение ответа от сервера
        String response = in.readLine();
        System.out.println("Сервер ответил: " + response);

        // Закрытие соединения
        socket.close();
    }
}
```

---

#### **Основные методы**  

#### **`ServerSocket`**  
| Метод | Описание |  
|-------|----------|  
| `ServerSocket(int port)` | Создает серверный сокет на указанном порту. |  
| `Socket accept()` | Ожидает подключения клиента (блокирующий вызов). |  
| `void close()` | Закрывает серверный сокет. |  

#### **`Socket`**  
| Метод | Описание |  
|-------|----------|  
| `Socket(String host, int port)` | Подключается к серверу по `host:port`. |  
| `InputStream getInputStream()` | Возвращает входной поток для чтения данных. |  
| `OutputStream getOutputStream()` | Возвращает выходной поток для записи данных. |  
| `void close()` | Закрывает соединение. |  

---

#### **Вывод**  
- **TCP** гарантирует надежную доставку данных.  
- **`ServerSocket`** используется на сервере для ожидания подключений.  
- **`Socket`** используется и на клиенте, и на сервере для обмена данными.  
- Работа с TCP в Java требует открытия потоков ввода-вывода (`InputStream`/`OutputStream`).  

Если нужно реализовать **многопоточный сервер**, можно использовать `ExecutorService` для обработки нескольких клиентов одновременно.





### 3. Протокол UDP. Классы `DatagramSocket` и `DatagramPacket`.
#### **Протокол UDP (User Datagram Protocol)**  

**UDP** — это **ненадежный**, **дейтаграммный** (без установления соединения) протокол транспортного уровня. Он используется, когда важна **скорость**, а не надежность доставки.  

##### **Ключевые особенности UDP:**  
✅ **Быстрая передача** (нет накладных расходов на установку соединения).  
✅ **Нет гарантии доставки** (пакеты могут теряться, дублироваться, приходить в неправильном порядке).  
✅ **Нет контроля перегрузки** (отправитель может завалить сеть пакетами).  
✅ **Подходит для:**  
   - VoIP (например, Skype, Zoom)  
   - Видеотрансляции (Twitch, YouTube Live)  
   - DNS-запросы  
   - Онлайн-игры (где важна низкая задержка)  

##### **Сравнение UDP и TCP**  
| Характеристика | TCP | UDP |  
|---------------|-----|-----|  
| **Надежность** | ✅ Гарантированная доставка | ❌ Нет гарантий |  
| **Порядок данных** | ✅ Сохраняется | ❌ Может нарушаться |  
| **Управление потоком** | ✅ Есть (контроль перегрузки) | ❌ Нет |  
| **Задержка** | Выше (из-за подтверждений) | Ниже (нет лишних handshake) |  
| **Примеры использования** | HTTP, FTP, SSH | DNS, VoIP, игры |  

---

#### **Классы `DatagramSocket` и `DatagramPacket` в Java**  

##### **1. `DatagramSocket`**  
Отвечает за отправку и получение UDP-пакетов.  

##### **2. `DatagramPacket`**  
Содержит данные (байтовый массив) и метаинформацию (IP-адрес, порт).  

---

#### **Пример UDP-сервера и клиента на Java**  

##### **🔹 UDP-сервер**  
```java
import java.net.*;

public class UDPServer {
    public static void main(String[] args) throws Exception {
        // Создаем сокет на порту 9876
        DatagramSocket serverSocket = new DatagramSocket(9876);
        byte[] receiveData = new byte[1024];

        System.out.println("UDP-сервер запущен...");

        while (true) {
            // Получаем пакет от клиента
            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
            serverSocket.receive(receivePacket); // Блокирующий вызов

            // Извлекаем данные и адрес клиента
            String message = new String(receivePacket.getData(), 0, receivePacket.getLength());
            InetAddress clientIP = receivePacket.getAddress();
            int clientPort = receivePacket.getPort();

            System.out.println("Клиент [" + clientIP + ":" + clientPort + "] сказал: " + message);

            // Отправляем ответ
            String response = "Сервер получил: " + message;
            byte[] sendData = response.getBytes();
            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, clientIP, clientPort);
            serverSocket.send(sendPacket);
        }
    }
}
```

##### **🔹 UDP-клиент**  
```java
import java.net.*;
import java.util.Scanner;

public class UDPClient {
    public static void main(String[] args) throws Exception {
        DatagramSocket clientSocket = new DatagramSocket();
        InetAddress serverIP = InetAddress.getByName("localhost");
        int serverPort = 9876;

        Scanner scanner = new Scanner(System.in);
        System.out.print("Введите сообщение: ");
        String message = scanner.nextLine();

        // Отправка пакета серверу
        byte[] sendData = message.getBytes();
        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverIP, serverPort);
        clientSocket.send(sendPacket);

        // Получение ответа от сервера
        byte[] receiveData = new byte[1024];
        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
        clientSocket.receive(receivePacket); // Блокирующий вызов

        String response = new String(receivePacket.getData(), 0, receivePacket.getLength());
        System.out.println("Ответ сервера: " + response);

        clientSocket.close();
    }
}
```

---

#### **Дополнительная информация**  

##### **🔸 Когда использовать UDP вместо TCP?**  
- **Видеостриминг** (потеря пакетов менее критична, чем задержка).  
- **Онлайн-игры** (FPS, MOBA — важна минимальная задержка).  
- **DNS-запросы** (быстрый однократный обмен).  
- **IoT-устройства** (например, датчики, отправляющие данные раз в минуту).  

##### **🔸 Минусы UDP**  
❌ **Нет контроля перегрузки** → может "зафлудить" сеть.  
❌ **Нет гарантии доставки** → нужно реализовывать подтверждения вручную (если нужно).  

##### **🔸 Примеры протоколов на основе UDP**  
- **DNS** (Domain Name System)  
- **DHCP** (Dynamic Host Configuration Protocol)  
- **QUIC** (основа HTTP/3)  
- **RTP** (Real-time Transport Protocol, используется в VoIP)  

---

#### **Вывод**  
- **UDP** — быстрый, но ненадежный протокол.  
- **`DatagramSocket`** — сокет для отправки/получения UDP-пакетов.  
- **`DatagramPacket`** — контейнер для данных (байты + адрес).  
- **Лучше всего подходит** для задач, где важна **низкая задержка**, а потери допустимы.  

Если нужна **надежность** — используйте **TCP**.  
Если важна **скорость** — выбирайте **UDP**.
### 4. Отличия блокирующего и неблокирующего ввода-вывода, их преимущества и недостатки. Работа с сетевыми каналами.
##### **Блокирующий и неблокирующий ввод-вывод (I/O) в сетевом программировании**

В сетевых приложениях работа с каналами (сокетами) может происходить в двух режимах:
1. **Блокирующий I/O** (синхронный)  
2. **Неблокирующий I/O** (асинхронный)  

Разберем их отличия, преимущества и недостатки.  

---

#### **1. Блокирующий ввод-вывод (Blocking I/O)**  
**Как работает:**  
- Когда поток вызывает операцию (например, `socket.read()` или `socket.accept()`), он **блокируется** до тех пор, пока данные не будут получены или соединение не установится.  
- Поток не может выполнять другие задачи, пока ждет.  

##### **🔹 Преимущества блокирующего I/O**  
✅ **Простота реализации** (код линейный и понятный).  
✅ **Хорошо подходит для простых клиент-серверных приложений** (например, однопоточный сервер).  

##### **🔹 Недостатки блокирующего I/O**  
❌ **Низкая производительность** (поток простаивает в ожидании данных).  
❌ **Плохая масштабируемость** (каждое новое соединение требует отдельного потока → большие накладные расходы).  
❌ **Риск зависания** (если клиент не отвечает, серверный поток может висеть вечно).  

##### **🔹 Пример блокирующего TCP-сервера (Java)**  
```java
ServerSocket serverSocket = new ServerSocket(8080);
while (true) {
    Socket clientSocket = serverSocket.accept(); // Блокируется, пока не придет клиент
    // Обработка клиента в этом же потоке
    BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    String message = in.readLine(); // Блокируется, пока не придут данные
    System.out.println("Получено: " + message);
    clientSocket.close();
}
```
**Проблема:**  
- Если клиент медленный, сервер не сможет принимать новых клиентов.  

---

#### **2. Неблокирующий ввод-вывод (Non-blocking I/O)**  
**Как работает:**  
- Операции ввода-вывода **не блокируют** поток.  
- Если данных нет, метод сразу возвращает управление (`SocketChannel.read()` вернет `0` или `-1`).  
- Для мониторинга событий используется **Selector** (Java NIO).  

##### **🔹 Преимущества неблокирующего I/O**  
✅ **Высокая производительность** (один поток может обрабатывать множество соединений).  
✅ **Масштабируемость** (подходит для высоконагруженных серверов).  
✅ **Нет простоев** (поток не блокируется и может выполнять другие задачи).  

##### **🔹 Недостатки неблокирующего I/O**  
❌ **Сложность реализации** (нужен механизм опроса событий, например, `Selector`).  
❌ **Требует больше кода** (обработка частичных данных, буферизация).  

##### **🔹 Пример неблокирующего сервера (Java NIO)**  
```java
Selector selector = Selector.open();
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.configureBlocking(false); // Неблокирующий режим
serverChannel.register(selector, SelectionKey.OP_ACCEPT); // Регистрируем событие "прием соединения"

while (true) {
    selector.select(); // Блокируется до появления событий
    Set<SelectionKey> keys = selector.selectedKeys();
    for (SelectionKey key : keys) {
        if (key.isAcceptable()) {
            // Принято новое соединение
            SocketChannel clientChannel = serverChannel.accept();
            clientChannel.configureBlocking(false);
            clientChannel.register(selector, SelectionKey.OP_READ); // Ждем данные
        } else if (key.isReadable()) {
            // Есть данные для чтения
            SocketChannel clientChannel = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = clientChannel.read(buffer); // Не блокируется!
            if (bytesRead > 0) {
                System.out.println("Получено: " + new String(buffer.array(), 0, bytesRead));
            }
        }
    }
    keys.clear();
}
```
**Плюсы:**  
- Один поток может обрабатывать тысячи соединений.  
- Нет простоев из-за ожидания.  

---

#### **3. Сравнение блокирующего и неблокирующего I/O**  

| Критерий               | Блокирующий I/O               | Неблокирующий I/O               |
|------------------------|-------------------------------|----------------------------------|
| **Блокировка потока**  | Да (поток ждет)               | Нет (возвращает управление)     |
| **Масштабируемость**   | Плохая (1 поток = 1 клиент)   | Хорошая (1 поток = N клиентов)  |
| **Сложность**          | Просто                       | Сложнее (нужен `Selector`)      |
| **Использование CPU**  | Низкое (поток спит)          | Высокое (постоянный опрос)      |
| **Подходит для**       | Простые серверы               | Высоконагруженные серверы       |

---

#### **4. Когда что использовать?**  
##### **🔹 Блокирующий I/O:**  
- Простые клиент-серверные приложения.  
- Низкая нагрузка (до 100 подключений).  
- Когда важна простота кода, а не производительность.  

##### **🔹 Неблокирующий I/O (NIO):**  
- Высоконагруженные серверы (чаты, онлайн-игры, стриминги).  
- Когда нужно обрабатывать тысячи соединений в одном потоке.  
- Когда важна минимальная задержка (например, VoIP).  

---

#### **Вывод**  
- **Блокирующий I/O** — прост, но плохо масштабируется.  
- **Неблокирующий I/O** — сложнее, но позволяет эффективно работать с множеством соединений.  
- **Java NIO (`Selector`, `SocketChannel`)** — лучший выбор для высоконагруженных серверов.  
- **TCP vs UDP:**  
  - TCP + блокирующий I/O → надежно, но медленно.  
  - UDP + неблокирующий I/O → быстро, но без гарантий доставки.  

Если нужно **масштабируемое решение** — используйте **неблокирующий I/O (NIO)**.  
Если важна **простота** — **блокирующий I/O**.

### 5. Классы `SocketChannel` и `DatagramChannel`.
### 6. Передача данных по сети. Сериализация объектов.
##### **Передача данных по сети и сериализация объектов в Java**

Для передачи объектов между клиентом и сервером их нужно преобразовать в последовательность байтов (**сериализовать**), отправить по сети, а затем восстановить (**десериализовать**). Рассмотрим ключевые аспекты этого процесса.

---

#### **1. Базовый механизм передачи объектов**

##### **🔹 Стандартная сериализация (`Serializable`)**
```java
// Объект для передачи
class Message implements Serializable {
    private String text;
    private int id;
    // ... геттеры/сеттеры
}
```

###### **Сервер (отправка объекта)**
```java
Message msg = new Message("Hello", 123);
try (ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream())) {
    oos.writeObject(msg);  // Сериализация и отправка
}
```

###### **Клиент (получение объекта)**
```java
try (ObjectInputStream ois = new ObjectInputStream(socket.getInputStream())) {
    Message receivedMsg = (Message) ois.readObject();  // Десериализация
    System.out.println(receivedMsg.getText());  // "Hello"
}
```

##### **🔹 Ограничения стандартного подхода**
- **Только Java**: Несовместимость с другими языками.
- **Размер данных**: Бинарный формат может быть избыточным.
- **Безопасность**: Уязвимости при десериализации недоверенных данных.

---

#### **2. Альтернативные методы сериализации**

##### **🔹 JSON (Gson/Jackson)**
**Преимущества**:
- Текстовый формат (человекочитаемый).
- Поддержка кросс-языковых приложений.
- Меньший риск уязвимостей.

**Пример с Gson**:
```java
// Сериализация в JSON
Gson gson = new Gson();
String json = gson.toJson(message);

// Отправка по сети (например, через PrintWriter)
PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
out.println(json);

// Десериализация на клиенте
BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
Message msg = gson.fromJson(in.readLine(), Message.class);
```

##### **🔹 Protocol Buffers (protobuf)**
**Преимущества**:
- Бинарный формат (высокая скорость и компактность).
- Автоматическая генерация кода.
- Схема данных (`*.proto`) гарантирует совместимость.

**Пример**:
```proto
// Определение сообщения в .proto-файле
message NetworkMessage {
  string text = 1;
  int32 id = 2;
}
```
```java
// Сериализация
NetworkMessage msg = NetworkMessage.newBuilder()
    .setText("Hello")
    .setId(123)
    .build();
byte[] data = msg.toByteArray();

// Отправка
OutputStream out = socket.getOutputStream();
out.write(data);

// Десериализация
InputStream in = socket.getInputStream();
NetworkMessage receivedMsg = NetworkMessage.parseFrom(in);
```

##### **🔹 Apache Avro / Apache Thrift**
Аналоги Protobuf, но с другими особенностями (например, Avro использует JSON-схемы).

---

#### **3. Сериализация в сетевых протоколах**

##### **🔹 TCP vs UDP**
| Характеристика | TCP | UDP |
|---------------|-----|-----|
| **Гарантия доставки** | ✅ Да | ❌ Нет |
| **Порядок данных** | ✅ Сохраняется | ❌ Может нарушаться |
| **Подходит для** | Передача файлов, HTTP | Видеостримы, игры |

###### **Пример отправки объекта через UDP (DatagramSocket)**
```java
// Сериализация
ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(message);
byte[] data = bos.toByteArray();

// Отправка
DatagramSocket socket = new DatagramSocket();
DatagramPacket packet = new DatagramPacket(
    data, data.length, InetAddress.getByName("localhost"), 9876
);
socket.send(packet);
```

---

#### **4. Проблемы и решения**

##### **🔹 Проблема: Несовместимость версий**
- **Симптом**: Ошибка `InvalidClassException` при изменении класса.
- **Решение**: Фиксировать `serialVersionUID`.
```java
class Message implements Serializable {
    private static final long serialVersionUID = 1L;  // Защита от изменений
}
```

##### **🔹 Проблема: Производительность**
- **Симптом**: Медленная сериализация больших объектов.
- **Решение**: Использовать **Protobuf** или **Kryo**.

##### **🔹 Проблема: Безопасность**
- **Риск**: Атаки через `ObjectInputStream` (например, Gadget-цепочки).
- **Решение**: 
  - Использовать **JSON** или **Protobuf**.
  - Белый список классов для десериализации:
  ```java
  ObjectInputStream ois = new ObjectInputStream(in) {
      @Override
      protected Class<?> resolveClass(ObjectStreamClass desc) 
          throws IOException, ClassNotFoundException {
          if (!desc.getName().equals("com.example.Message")) {
              throw new InvalidClassException("Неразрешенный класс");
          }
          return super.resolveClass(desc);
      }
  };
  ```

---

#### **5. Итоговая таблица методов**

| Метод | Формат | Скорость | Безопасность | Кросс-языковость |
|-------|--------|----------|--------------|-------------------|
| **Java Serializable** | Бинарный | Средняя | ❌ Низкая | ❌ Только Java |
| **JSON (Gson/Jackson)** | Текстовый | Низкая | ✅ Высокая | ✅ Да |
| **Protobuf** | Бинарный | ✅ Высокая | ✅ Высокая | ✅ Да |
| **Kryo** | Бинарный | ✅ Очень высокая | ❌ Средняя | ❌ Только Java |

---

#### **Вывод**
1. **Для Java-приложений**: 
   - Используйте стандартную сериализацию (`Serializable`) для простых случаев.
   - Оптимизируйте производительность через **Kryo**.
2. **Для кросс-языковых систем**: 
   - Выбирайте **JSON** (если нужна читаемость) или **Protobuf** (для скорости).
3. **Для реального времени (игры, стримы)**: 
   - **UDP + Protobuf** (минимальная задержка).
4. **Всегда**: 
   - Избегайте десериализации недоверенных данных.
   - Фиксируйте `serialVersionUID` для совместимости.

### 7. Интерфейс `Serializable`. Объектный граф, сериализация и десериализация полей и методов.
#### **Интерфейс `Serializable` в Java: объектный граф, сериализация и десериализация**

##### **1. Что такое `Serializable`?**
`Serializable` — это **маркерный интерфейс** (не имеет методов), который указывает, что объект может быть преобразован в последовательность байтов (**сериализован**) и восстановлен из нее (**десериализован**).  

###### **🔹 Основные понятия**
- **Сериализация** — процесс преобразования объекта в поток байтов.  
- **Десериализация** — восстановление объекта из потока байтов.  
- **Объектный граф** — все связанные объекты, которые будут сериализованы вместе с исходным.  

######### **🔹 Пример базовой сериализации**
```java
import java.io.*;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class SerializationExample {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Person person = new Person("Alice", 30);

        // Сериализация
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            oos.writeObject(person);
        }

        // Десериализация
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person deserializedPerson = (Person) ois.readObject();
            System.out.println(deserializedPerson); // Person{name='Alice', age=30}
        }
    }
}
```

---

##### **2. Как работает сериализация?**
###### **🔹 Что сериализуется?**
- **Все нестатические поля** (включая `private`).  
- **Ссылки на другие объекты** (рекурсивно, формируется **объектный граф**).  

###### **🔹 Что НЕ сериализуется?**
- `static` поля (принадлежат классу, а не объекту).  
- `transient` поля (помечены как несериализуемые).  
- Методы (сериализуется только состояние объекта, не поведение).  

###### **🔹 Объектный граф**
При сериализации объекта **сериализуются все связанные объекты**, на которые есть ссылки (если они тоже `Serializable`).  

**Пример:**
```java
class Address implements Serializable {
    private String city;
    public Address(String city) { this.city = city; }
}

class User implements Serializable {
    private String name;
    private Address address; // Будет сериализован, если Address — Serializable
}
```

**Если вложенный объект не `Serializable` → `NotSerializableException`.**

---

##### **3. Управление процессом сериализации**
###### **🔹 `transient` — исключение поля из сериализации**
```java
class Person implements Serializable {
    private String name;
    private transient int age; // Не будет сериализовано
}
```

###### **🔹 Кастомная сериализация через `writeObject` и `readObject`**
```java
private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject(); // Стандартная сериализация
    out.writeInt(age * 2); // Дополнительная логика
}

private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject(); // Стандартная десериализация
    this.age = in.readInt() / 2; // Восстановление поля
}
```

###### **🔹 `serialVersionUID` — контроль версий класса**
```java
class Person implements Serializable {
    private static final long serialVersionUID = 1L; // Уникальный идентификатор
}
```
- Если не задать `serialVersionUID`, он вычисляется автоматически (может измениться при модификации класса → ошибка десериализации).  
- Рекомендуется явно указывать `serialVersionUID`.  

---

##### **4. Сериализация и наследование**
- Если родительский класс не `Serializable`, его поля **не сериализуются** (но дочерний может быть `Serializable`).  
- Если родительский класс `Serializable`, то и все его потомки автоматически поддерживают сериализацию.  

**Пример:**
```java
class Animal {
    private String type = "Unknown"; // Не сериализуется, если Animal не Serializable
}

class Dog extends Animal implements Serializable {
    private String name; // Сериализуется
}
```

---

##### **5. Проблемы и ограничения**
###### **🔹 Безопасность**
- Сериализованные данные можно модифицировать (риск инъекций).  
- Альтернативы: **JSON (Gson, Jackson)**, **Protocol Buffers**, **Kryo**.  

###### **🔹 Производительность**
- Сериализация через `ObjectOutputStream` медленнее, чем бинарные форматы (например, **Protobuf**).  

###### **🔹 Совместимость**
- Изменения в классе могут сломать десериализацию.  
- Решение: использовать `serialVersionUID` и кастомные методы `writeObject`/`readObject`.  

---

##### **Вывод**
- **`Serializable`** — механизм сохранения и восстановления объектов в Java.  
- **Объектный граф** — все связанные объекты, которые сериализуются вместе.  
- **`transient`** — исключает поле из сериализации.  
- **`serialVersionUID`** — защита от ошибок при изменении класса.  
- **Кастомная сериализация** — через `writeObject`/`readObject`.  

**Лучшие практики:**
✅ Всегда указывайте `serialVersionUID`.  
✅ Используйте `transient` для чувствительных данных.  
✅ Для сложных сценариев — кастомная сериализация.  
✅ Альтернативы: **JSON, Protobuf, Kryo** (если нужна скорость/безопасность).

### 8. Java Stream API. Создание конвейеров. Промежуточные и терминальные операции.
#### **Java Stream API: создание конвейеров, промежуточные и терминальные операции**  

Stream API — это мощный инструмент для работы с коллекциями и данными в функциональном стиле. Он позволяет писать лаконичный и выразительный код, избегая явных циклов и временных переменных.  

##### **1. Основные понятия**  
###### **1.1 Что такое Stream?**  
`Stream<T>` — это последовательность элементов, поддерживающая различные операции (фильтрацию, преобразование, агрегацию и т. д.).  

**Особенности Stream:**  
- **Не хранит данные** (это не структура данных, а конвейер для обработки).  
- **Не изменяет источник** (все операции возвращают новый `Stream`).  
- **Ленивые вычисления** (промежуточные операции выполняются только при вызове терминальной).  
- **Одноразовый** (после терминальной операции `Stream` нельзя использовать повторно).  

###### **1.2 Создание Stream**  
```java
// Из коллекции
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream1 = list.stream();

// Из массива
String[] array = {"a", "b", "c"};
Stream<String> stream2 = Arrays.stream(array);

// Из значений
Stream<String> stream3 = Stream.of("a", "b", "c");

// Бесконечный Stream (generate / iterate)
Stream<String> stream4 = Stream.generate(() -> "hello");
Stream<Integer> stream5 = Stream.iterate(0, n -> n + 1);
```

---

##### **2. Промежуточные операции (Intermediate Operations)**  
Промежуточные операции возвращают новый `Stream` и выполняются **лениво** (только при вызове терминальной операции).  

###### **2.1 Фильтрация**  
- `filter(Predicate<T>)` — оставляет элементы, удовлетворяющие условию.  
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.stream()
     .filter(name -> name.length() > 4)
     .forEach(System.out::println); // "Alice", "Charlie"
```

###### **2.2 Преобразование**  
- `map(Function<T, R>)` — преобразует каждый элемент.  
```java
List<String> names = Arrays.asList("Alice", "Bob");
names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println); // "ALICE", "BOB"
```

- `flatMap(Function<T, Stream<R>>)` — "разворачивает" вложенные структуры.  
```java
List<List<String>> nestedList = Arrays.asList(
    Arrays.asList("a", "b"),
    Arrays.asList("c", "d")
);
nestedList.stream()
          .flatMap(List::stream)
          .forEach(System.out::println); // "a", "b", "c", "d"
```

###### **2.3 Сортировка и уникальность**  
- `sorted()` / `sorted(Comparator<T>)` — сортировка.  
```java
Stream.of(3, 1, 2)
      .sorted()
      .forEach(System.out::println); // 1, 2, 3
```

- `distinct()` — удаляет дубликаты.  
```java
Stream.of(1, 2, 2, 3)
      .distinct()
      .forEach(System.out::println); // 1, 2, 3
```

###### **2.4 Ограничение и пропуск**  
- `limit(long)` — ограничивает количество элементов.  
- `skip(long)` — пропускает первые `n` элементов.  
```java
Stream.iterate(0, n -> n + 1)
      .skip(5)
      .limit(3)
      .forEach(System.out::println); // 5, 6, 7
```

###### **2.5 Просмотр элементов (peek)**  
- `peek(Consumer<T>)` — выполняет действие для каждого элемента (обычно для отладки).  
```java
Stream.of("a", "b", "c")
      .peek(System.out::println) // "a", "b", "c"
      .map(String::toUpperCase)
      .forEach(System.out::println); // "A", "B", "C"
```

---

##### **3. Терминальные операции (Terminal Operations)**  
Терминальные операции **запускают выполнение Stream** и возвращают результат (не `Stream`).  

###### **3.1 Итерация (forEach)**  
- `forEach(Consumer<T>)` — выполняет действие для каждого элемента.  
```java
Stream.of("a", "b").forEach(System.out::println); // "a", "b"
```

###### **3.2 Сбор в коллекцию (collect)**  
- `collect(Collector)` — собирает элементы в коллекцию (`List`, `Set`, `Map` и др.).  
```java
List<String> list = Stream.of("a", "b", "c")
                          .collect(Collectors.toList());

Set<String> set = Stream.of("a", "a", "b")
                        .collect(Collectors.toSet());

Map<String, Integer> map = Stream.of("a", "bb", "ccc")
    .collect(Collectors.toMap(
        s -> s,           // ключ
        String::length    // значение
    )); // {"a":1, "bb":2, "ccc":3}
```

###### **3.3 Поиск и проверка (anyMatch, allMatch, noneMatch)**  
- `anyMatch(Predicate<T>)` — true, если хотя бы один элемент соответствует условию.  
- `allMatch(Predicate<T>)` — true, если все элементы соответствуют условию.  
- `noneMatch(Predicate<T>)` — true, если ни один элемент не соответствует.  
```java
boolean hasEven = Stream.of(1, 3, 5).anyMatch(n -> n % 2 == 0); // false
boolean allPositive = Stream.of(1, 2, 3).allMatch(n -> n > 0);  // true
```

###### **3.4 Поиск первого элемента (findFirst, findAny)**  
- `findFirst()` — возвращает первый элемент (важно для параллельных Stream).  
- `findAny()` — возвращает любой элемент (оптимизирован для параллелизма).  
```java
Optional<String> first = Stream.of("a", "b").findFirst(); // "a"
```

###### **3.5 Агрегация (reduce, min, max, count, sum)**  
- `reduce(BinaryOperator<T>)` — сводит Stream к одному значению.  
```java
Optional<Integer> sum = Stream.of(1, 2, 3)
    .reduce((a, b) -> a + b); // 6
```

- `count()` — количество элементов.  
```java
long count = Stream.of("a", "b").count(); // 2
```

- `min()`, `max()` — минимальный/максимальный элемент.  
```java
Optional<String> min = Stream.of("a", "bb", "ccc")
    .min(Comparator.comparingInt(String::length)); // "a"
```

###### **3.6 Статистика (summaryStatistics)**  
Полезно для числовых Stream (`IntStream`, `DoubleStream`, `LongStream`):  
```java
IntSummaryStatistics stats = IntStream.of(1, 2, 3).summaryStatistics();
System.out.println(stats.getAverage()); // 2.0
System.out.println(stats.getMax());     // 3
```

---

##### **4. Примеры конвейеров Stream**  

###### **4.1 Фильтрация + преобразование + сбор в List**  
```java
List<String> result = Stream.of("apple", "banana", "cherry")
    .filter(fruit -> fruit.length() > 5)
    .map(String::toUpperCase)
    .collect(Collectors.toList()); // ["BANANA", "CHERRY"]
```

###### **4.2 Группировка (groupingBy)**  
```java
Map<Integer, List<String>> grouped = Stream.of("a", "bb", "cc", "d")
    .collect(Collectors.groupingBy(String::length));
// {1=["a", "d"], 2=["bb", "cc"]}
```

###### **4.3 Объединение строк (joining)**  
```java
String joined = Stream.of("a", "b", "c")
    .collect(Collectors.joining(", ")); // "a, b, c"
```

###### **4.4 Параллельная обработка (parallelStream)**  
```java
List<String> list = Arrays.asList("a", "b", "c");
list.parallelStream()
    .map(String::toUpperCase)
    .forEach(System.out::println); // Порядок не гарантирован!
```

---

##### **5. Важные замечания**  
- **Stream нельзя использовать повторно** (после терминальной операции он закрывается).  
- **Промежуточные операции выполняются лениво** (только при вызове терминальной).  
- **Порядок операций важен** (фильтрацию лучше делать до преобразования).  
- **Параллельные Stream** ускоряют обработку больших данных, но могут быть неэффективны для малых коллекций.  

---

#### **Вывод**  
Stream API позволяет писать **чистый, декларативный код**, избегая императивных циклов.  
- **Промежуточные операции** (`filter`, `map`, `sorted`...) формируют конвейер.  
- **Терминальные операции** (`collect`, `forEach`, `reduce`...) запускают выполнение.  

**Совет для защиты:**  
- Приводи примеры из реальных проектов (например, обработка данных из БД).  
- Объясняй преимущества перед классическими циклами (`for`, `while`).  
- Упомяни **ленивые вычисления** и **одноразовость Stream**.  

### 9. Шаблоны проектирования: Decorator, Iterator, Factory method, Command, Flyweight, Interpreter, Singleton, Strategy, Adapter, Facade, Proxy.

#### **Шаблоны проектирования в Java**  

Шаблоны проектирования — это проверенные решения типичных проблем в разработке ПО. Они ускоряют разработку, делают код более читаемым и поддерживаемым.  

Все шаблоны делятся на **3 категории**:  
1. **Порождающие** (Creational) — создание объектов.  
2. **Структурные** (Structural) — композиция классов и объектов.  
3. **Поведенческие** (Behavioral) — взаимодействие между объектами.  

Рассмотрим каждый из указанных шаблонов.  

---

##### **1. Decorator (Декоратор) — структурный шаблон**  
**Назначение:** Динамически добавляет объекту новые функциональности, не изменя его структуру.  

**Пример:**  
```java
// Базовый интерфейс
interface Coffee {
    String getDescription();
    double cost();
}

// Конкретная реализация
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Простой кофе";
    }

    @Override
    public double cost() {
        return 2.0;
    }
}

// Декоратор
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost();
    }
}

// Конкретный декоратор (добавляет молоко)
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", с молоком";
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost() + 0.5;
    }
}

// Использование
Coffee coffee = new MilkDecorator(new SimpleCoffee());
System.out.println(coffee.getDescription() + " - $" + coffee.cost());
// Вывод: "Простой кофе, с молоком - $2.5"
```  

**Где применяется?**  
- В Java I/O (`BufferedReader`, `ZipInputStream` — это декораторы для `InputStream`).  
- В GUI-библиотеках (добавление скролла, рамок).  

**Плюсы:**  
- Гибкость (можно комбинировать декораторы).  
- Соответствует **Open/Closed Principle** (классы закрыты для изменения, но открыты для расширения).  

**Минусы:**  
- Может привести к большому количеству маленьких классов.  

---

##### **2. Iterator (Итератор) — поведенческий шаблон**  
**Назначение:** Предоставляет способ последовательного доступа к элементам коллекции без раскрытия её внутренней структуры.  

**Пример:**  
```java
interface Iterator<T> {
    boolean hasNext();
    T next();
}

class Book {
    private String title;
    public Book(String title) { this.title = title; }
    public String getTitle() { return title; }
}

class BookCollection implements Iterable<Book> {
    private List<Book> books = new ArrayList<>();

    public void addBook(Book book) {
        books.add(book);
    }

    @Override
    public Iterator<Book> iterator() {
        return new BookIterator();
    }

    private class BookIterator implements Iterator<Book> {
        private int index = 0;

        @Override
        public boolean hasNext() {
            return index < books.size();
        }

        @Override
        public Book next() {
            return books.get(index++);
        }
    }
}

// Использование
BookCollection collection = new BookCollection();
collection.addBook(new Book("1984"));
collection.addBook(new Book("Java Core"));

for (Book book : collection) {
    System.out.println(book.getTitle());
}
```  

**Где применяется?**  
- Все коллекции в Java (`List`, `Set`, `Map`).  
- Обход деревьев, графов.  

**Плюсы:**  
- Унифицированный доступ к разным коллекциям.  
- Скрывает внутреннюю реализацию.  

**Минусы:**  
- Избыточен для простых структур (например, массива).  

---

##### **3. Factory Method (Фабричный метод) — порождающий шаблон**  
**Назначение:** Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.  

**Пример:**  
```java
interface Transport {
    void deliver();
}

class Truck implements Transport {
    @Override
    public void deliver() {
        System.out.println("Доставка грузовиком");
    }
}

class Ship implements Transport {
    @Override
    public void deliver() {
        System.out.println("Доставка кораблём");
    }
}

abstract class Logistics {
    public abstract Transport createTransport();

    public void planDelivery() {
        Transport transport = createTransport();
        transport.deliver();
    }
}

class RoadLogistics extends Logistics {
    @Override
    public Transport createTransport() {
        return new Truck();
    }
}

class SeaLogistics extends Logistics {
    @Override
    public Transport createTransport() {
        return new Ship();
    }
}

// Использование
Logistics logistics = new RoadLogistics();
logistics.planDelivery(); // "Доставка грузовиком"
```  

**Где применяется?**  
- `java.util.Calendar#getInstance()`  
- `java.text.NumberFormat#getInstance()`  

**Плюсы:**  
- Гибкость (можно добавлять новые типы продуктов).  
- Избавляет клиентский код от привязки к конкретным классам.  

**Минусы:**  
- Много параллельных иерархий классов.  

---

##### **4. Command (Команда) — поведенческий шаблон**  
**Назначение:** Инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, ставить их в очередь или логировать.  

**Пример:**  
```java
interface Command {
    void execute();
}

class Light {
    void turnOn() { System.out.println("Свет включён"); }
    void turnOff() { System.out.println("Свет выключен"); }
}

class TurnOnCommand implements Command {
    private Light light;

    public TurnOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn();
    }
}

class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}

// Использование
Light light = new Light();
Command turnOn = new TurnOnCommand(light);

RemoteControl remote = new RemoteControl();
remote.setCommand(turnOn);
remote.pressButton(); // "Свет включён"
```  

**Где применяется?**  
- GUI-кнопки, действия в меню.  
- Отмена/повтор операций (Undo/Redo).  

**Плюсы:**  
- Отделяет отправителя команды от её исполнителя.  
- Позволяет собирать команды в очередь.  

**Минусы:**  
- Усложняет код из-за дополнительных классов.  

---

##### **5. Flyweight (Легковес) — структурный шаблон**  
**Назначение:** Экономит память, разделяя общее состояние между множеством объектов.  

**Пример:**  
```java
class TreeType {
    private String name;
    private String color;

    public TreeType(String name, String color) {
        this.name = name;
        this.color = color;
    }

    public void draw(int x, int y) {
        System.out.printf("Рисуем %s дерево (%s) в точке (%d, %d)\n", name, color, x, y);
    }
}

class TreeFactory {
    private static Map<String, TreeType> treeTypes = new HashMap<>();

    public static TreeType getTreeType(String name, String color) {
        String key = name + "_" + color;
        if (!treeTypes.containsKey(key)) {
            treeTypes.put(key, new TreeType(name, color));
        }
        return treeTypes.get(key);
    }
}

class Tree {
    private int x, y;
    private TreeType type;

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw() {
        type.draw(x, y);
    }
}

// Использование
TreeType oakType = TreeFactory.getTreeType("Дуб", "Зелёный");
Tree tree1 = new Tree(10, 20, oakType);
Tree tree2 = new Tree(30, 40, oakType);

tree1.draw(); // "Рисуем Дуб дерево (Зелёный) в точке (10, 20)"
tree2.draw(); // "Рисуем Дуб дерево (Зелёный) в точке (30, 40)"
```  

**Где применяется?**  
- Символы в текстовом редакторе.  
- Игровые миры (например, деревья, трава).  

**Плюсы:**  
- Экономит память.  
- Уменьшает количество создаваемых объектов.  

**Минусы:**  
- Усложняет код из-за разделяемого состояния.  

---

###### **6. Interpreter (Интерпретатор) — поведенческий шаблон**  
**Назначение:** Определяет грамматику языка и интерпретирует предложения этого языка.  

**Пример (простой калькулятор):**  
```java
interface Expression {
    int interpret();
}

class Number implements Expression {
    private int value;

    public Number(int value) {
        this.value = value;
    }

    @Override
    public int interpret() {
        return value;
    }
}

class Add implements Expression {
    private Expression left, right;

    public Add(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public int interpret() {
        return left.interpret() + right.interpret();
    }
}

// Использование
Expression expr = new Add(new Number(5), new Number(3));
System.out.println(expr.interpret()); // 8
```  

**Где применяется?**  
- SQL-парсеры.  
- Регулярные выражения.  

**Плюсы:**  
- Легко расширяем (можно добавлять новые правила).  

**Минусы:**  
- Сложен для больших грамматик.  

---

#### **7. Singleton (Одиночка) — порождающий шаблон**  
**Назначение:** Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.  

**Пример (потокобезопасный Singleton):**  
```java
class Database {
    private static volatile Database instance;

    private Database() {}

    public static Database getInstance() {
        if (instance == null) {
            synchronized (Database.class) {
                if (instance == null) {
                    instance = new Database();
                }
            }
        }
        return instance;
    }
}
```  

**Где применяется?**  
- Логгеры (`Logger`).  
- Подключения к БД.  

**Плюсы:**  
- Контроль доступа к ресурсу.  

**Минусы:**  
- Нарушает **Single Responsibility Principle**.  
- Сложность тестирования.  

---

#### **8. Strategy (Стратегия) — поведенческий шаблон**  
**Назначение:** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.  

**Пример:**  
```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Оплата картой: $" + amount);
    }
}

class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Оплата PayPal: $" + amount);
    }
}

class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout(int amount) {
        paymentStrategy.pay(amount);
    }
}

// Использование
ShoppingCart cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardPayment());
cart.checkout(100); // "Оплата картой: $100"
```  

**Где применяется?**  
- Сортировка (`Comparator` в Java).  
- Разные алгоритмы сжатия данных.  

**Плюсы:**  
- Замена алгоритмов на лету.  
- Избегание условных операторов.  

**Минусы:**  
- Увеличивает количество классов.  

---

#### **9. Adapter (Адаптер) — структурный шаблон**  
**Назначение:** Позволяет объектам с несовместимыми интерфейсами работать вместе.  

**Пример:**  
```java
interface EuropeanSocket {
    void plugInEurope();
}

class AmericanSocket {
    void plugInAmerica() {
        System.out.println("Вставлено в американскую розетку");
    }
}

class SocketAdapter implements EuropeanSocket {
    private AmericanSocket americanSocket;

    public SocketAdapter(AmericanSocket socket) {
        this.americanSocket = socket;
    }

    @Override
    public void plugInEurope() {
        americanSocket.plugInAmerica();
        System.out.println("Адаптер преобразует в евроразъём");
    }
}

// Использование
AmericanSocket usSocket = new AmericanSocket();
EuropeanSocket adapter = new SocketAdapter(usSocket);
adapter.plugInEurope();
```  

**Где применяется?**  
- `java.util.Arrays#asList()`  
- `java.io.InputStreamReader` (адаптирует `InputStream` к `Reader`)  

**Плюсы:**  
- Совместимость несовместимых интерфейсов.  

**Минусы:**  
- Усложняет код.  

---

#### **10. Facade (Фасад) — структурный шаблон**  
**Назначение:** Предоставляет простой интерфейс к сложной системе классов.  

**Пример:**  
```java
class CPU {
    void start() { System.out.println("CPU запущен"); }
}

class Memory {
    void load() { System.out.println("Память загружена"); }
}

class ComputerFacade {
    private CPU cpu;
    private Memory memory;

    public ComputerFacade() {
        this.cpu = new CPU();
        this.memory = new Memory();
    }

    public void start() {
        cpu.start();
        memory.load();
        System.out.println("Компьютер запущен");
    }
}

// Использование
ComputerFacade computer = new ComputerFacade();
computer.start();
```  

**Где применяется?**  
- Упрощение работы с API.  
- ORM (например, Hibernate).  

**Плюсы:**  
- Упрощает использование сложных систем.  

**Минусы:**  
- Может стать "божественным объектом".  

---

#### **11. Proxy (Прокси) — структурный шаблон**  
**Назначение:** Позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые контролируют доступ к ним.  

**Пример (ленивая загрузка):**  
```java
interface Image {
    void display();
}

class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Загрузка изображения: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Показ изображения: " + filename);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}

// Использование
Image image = new ProxyImage("photo.jpg");
image.display(); // Загрузит и покажет
image.display(); // Покажет сразу (уже загружено)
```  

**Где применяется?**  
- Ленивая инициализация (`Hibernate`).  
- Защита доступа (`Security Proxy`).  
- Кэширование (`Caching Proxy`).  

**Плюсы:**  
- Контроль доступа к объекту.  
- Ленивая загрузка.  

**Минусы:**  
- Увеличивает время отклика.  

---

#### **Вывод**  
Каждый шаблон решает определённую проблему. Важно понимать, когда и какой применять.  

**Совет для защиты:**  
- Приводи реальные примеры из Java Core (`Collections`, `IO`, `JDBC`).  
- Объясняй, какие принципы SOLID поддерживает шаблон.  
- Говори о плюсах/минусах и альтернативах.  
- 
